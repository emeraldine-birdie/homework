package com.multithreading.operators.bitwise_operators.max_power_of_2;

    /*
    Реализуй логику метода maxPowerOf2, который должен возвращать число 2 в максимальной степени,
    которое получается поместить в переданное число.
    Аргументом maxPowerOf2 может быть только положительное целое число.

    Используй только операции:
    1. Побитовые сдвиги.
    2. Побитовое OR.
    3. Побитовое AND.
    4. Побитовый унарный оператор NOT.
    5. Присваивание (можно совмещать разрешенные операции с присваивание, например, &=).
    6. Круглые скобки.
    */

public class Solution {
    public static void main(String[] args) {
        System.out.println(maxPowerOf2(140_000));   //131072
        System.out.println(maxPowerOf2(1026));      //1024
        System.out.println(maxPowerOf2(17));        //16
    }

    public static int maxPowerOf2(int x) {
        /*
         * 17 = 0001_0001   1026 = 0100_0000_0010   140_000 = 0010_0010_0010_1110_0000
         * 16 = 0001_0000   1024 = 0100_0000_0000   131_072 = 0010_0000_0000_0000_0000
         *
         * при переводе чисел в двоичное представление становится понятно, что условие задачи можно перефразировать,
         * как обнуление всех битов, кроме старшего, что уже реализовано в одной из предыдущих задач
         * multithreading.operators.number_systems.MinBase
         */

        x |= x >> 1;
        x |= x >> 2;
        x |= x >> 4;
        x |= x >> 8;
        x |= x >> 16;
        x &= ~x >> 1;

        return x;
    }
}
